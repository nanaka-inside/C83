.. -*- coding: utf-8 -*-

################################
CI、してますか？（ミスター風に）
################################

こんにちは、 ``@mtgto`` です。みなさん趣味プロしてますか？（挨拶）

このセクションではJenkinsの活用方法の紹介、gitを使っているプロジェクトとの連携、gitのフックスクリプトの紹介を行います。

=============
Jenkinsの紹介
=============
JenkinsはJavaで作られている「継続的インテグレーション (Continuous Integration)」をサポートするツールです。
私は今の会社に入社してからプロジェクトでJenkinsを経験し、趣味で作っているプログラムについてもJenkinsによる管理を行うようになったくらいハマっています。
ScalaやiPhoneのプロジェクトをソースコードリポジトリへの変更があった時にビルド＆テストを行なってくれるので、
常にテストが通っている状態での環境で開発をすることができるようになっています。
それ以外にも共有環境の状態が正常であるかどうかといったビルドを伴わないチェックも定期的に実行してくれています。
この原稿もJenkinsによる自動PDF生成が行われています [#jenkins_tboffice]_ 。

.. [#jenkins_tboffice] 「Git + Jenkins + Sphinxでドキュメント生成」を見てね！


(Jenkinsを使ったことがない人向け)まずはダウンロードしたjenkins.warを使って起動してみましょう。

Javaの起動オプションに"-Dfile.encoding=UTF-8"をつけないと、通常の使用時にはほとんど問題がありませんがビルドログの表示時に文字化けが起きるなど
わかりづらいトラブルに巻き込まれる [#jenkins_trouble]_ ので
なお、jenkinsはデフォルトで8080ポートで起動するため、すでに使用されている時には
ポートを変えて起動しましょう。
ポートを変えるには起動オプションに"--httpPort=8081"のように記述することで可能です。::

.. code-block:: bash

  java -jar jenkins.war -Dfile.encoding=UTF-8 --httpPort=8081

.. rubric:: 脚注
.. [#jenkins_trouble] 私のことです

.. image:: images/jenkins_top.eps

----------------------
tomcatへのインストール
----------------------
普段使用しているMacBook AirにもJenkinsを入れて趣味のプログラムの管理をしているのですが、
Jenkins以外にもJavaのサーブレットを使いたい場合はTomcatを使うと便利なのかなーと思ってTomcat 7で稼働させています。メモリもちょっと節約できるし。

Tomcatのインストール手順は様々なサイトにお任せしますが、
私の環境では自分だけが使用するので自分のユーザ権限でインストールしてしまいます。
MacなのでHomebrewを使って::

  brew install tomcat

$CATALINA_HOME/conf/server.xmlのコネクタ定義にURIEncodingを追加::

  <Connector port="8080" URIEncoding="UTF-8"/>

環境変数$CATALINA_OPTSでjenkinsホームパスを設定 (なぜか名前がHudsonのままになってる...)::

  export CATALINA_OPTS="-DHUDSON_HOME=~/.jenkins -Xmx512m"

Tomcatを起動::

  catalina start

http://localhost:8080/manager/html/list からjenkins.warをアップロードし、しばらくしてから
http://localhost:8080/jenkins/ にアクセスするとJenkinsのメイン画面が表示されます。

================
ビルド結果の通知
================
ビルドに失敗したらすぐにそれに気づかないといけません。

Jenkinsのプラグインのページを見ると "notifi" での検索結果が30件以上あり、メールやSkype, IRCなどで通知してくれるものや、音やGrowlで通知してくれるものがあります。
ここではGrowlへの通知を紹介します。

-------------
Growlへの通知
-------------
Growl 2.0 (Mac)、Jenkins Growl Plugin 1.1を使って説明します。
1. Growlの環境設定のネットワークを開く
2. 「外部からの通知を受け付ける」のチェックを入れる
3. サーバのパスワードを設定する
4. Jenkinsの「プラグインの管理」から「Jenkins Growl Plugin」をインストールする
5. Jenkinsの「システムの設定」の「Global Growl Settings」のパスワードに先ほど設定したGrowlのサーバパスワードを設定する

あとは使いたいジョブの設定でビルド後の処理に「Growl」を追加し、IP AddressにGrowlのサーバのアドレス（ローカルで起動している場合は127.0.0.1）を指定すればOKです。

.. figure:: images/growl.eps
  :align: center

  Growlにビルド結果が表示される

----------------------------------
CCMenuによるビルド結果の表示 (Mac)
----------------------------------
Macな人に限りますが、CCMenu (http://ccmenu.sourceforge.net/ ) を使うとメニューバーに
すべてのジョブが成功しているときは緑のアイコン、一個でもジョブが失敗していると赤いアイコンが表示されます。
細かい設定はできませんがJenkinsの健康状態を常に画面に表示することができ、私は気に入っています。

=========================
git-hooksで自動テスト実行
=========================
さて本題。gitのリポジトリに変更があった時に毎回テストを実行しましょう。
リポジトリの変更を検知する場合、jenkinsのSCMポーリング機能を使って実現することは簡単ですが、SCMサーバに不要な負荷がかかることになります [#jenkins_polling]_ 。

.. [#jenkins_polling] 作者の川口氏もポーリングは非効率といっています。参照：http://kohsuke.org/2011/12/01/polling-must-die-triggering-jenkins-builds-from-a-git-hook/

--------------------
一人で開発している時
--------------------
一人で開発している時には、

  Jenkinsの起動しているサーバ = 開発サーバ

なので、コミットごとにJenkinsビルドを実行するようにします。

コミットごとにビルドを行うときにはgitのフックスクリプトの中の ``post-update`` を使います。 ``post-update`` はコミットが完了した時にgitコマンドが自動的に実行してくれます。
Jenkinsのビルドを実行するにはJenkinsの起動しているサーバに対してhttp getを送ることで実行できます。

.. code-block:: bash
  :linenos:

  #!/bin/sh
  BASE_URL=http://<TOMCAT_SERVER>:8080/jenkins/job/<JOB_NAME>
  URL="${BASE_URL}/build?delay=0"
  curl -q "${URL}"
  if [ $? -eq 0 ]; then
          echo "start jenkins build at ${BASE_URL}."
  else
          echo "failure to start jenkins build at ${BASE_URL}."
  fi


上記スクリプトの ``<TOMCAT_SERVER>`` となっている場所を自分のJenkinsが動いている場所に、 ``<JOB_NAME>`` をJenkinsのジョブ名に変更してください。
これを ``.git/hooks/post-commit`` として保存し、 ``chmod +x .git/hooks/post-commit`` しておくとコミットの実行時にジョブが実行されるようになります。

--------------
チーム開発の時
--------------
チーム開発をしている場合は共通のリポジトリがあると思うので、リモートリポジトリへのpushのタイミングでJenkinsのビルドを行うようにしましょう。
リモートリポジトリの ``hooks/post-update`` に (または ``hook/spost-receive`` ) しかけることでそれが実現できます。リモートには.gitディレクトリはないので注意しましょう。
ファイルの内容は一人の開発の時の同じです。

=====================
その他のgit-hooksたち
=====================
gitで使えるフックスクリプトの説明はコンソールからgit help hooksを実行することで見ることができます。

------------------------------------------------
git am (Eメールにあるパッチの操作)のためのフック
------------------------------------------------
applypatch-msg
  引数として当てようとしているパッチのコミットログが書かれたファイルパスを受け取る。
  このスクリプトが終了コード0以外で終了するとパッチを当てる作業が中断される。
  コミットログの修正も可能。
  サンプルでは (commit-msgが設定されていれば) commit-msgフックを実行する。
pre-applypatch
  パッチが実行されたあと、コミットされる前に呼び出される。引数はなし。
  このスクリプトが終了コード0以外で終了するとコミットせずにパッチ作業が終了される。
  ワーキングツリーの状態を調べてコミットしていいかを検査するために使える。
  サンプルでは (pre-commitが設定されていれば) pre-commitフックを実行する。
post-applypatch
  パッチとコミットが完了したあとに呼び出される。
  パッチ処理自体への操作ではなく、完了したことの通知をする目的で使う。

--------------------------
クライアントサイド用フック
--------------------------
pre-commit
  commitを実行した時にコミットメッセージを書く前に呼び出される。
  ``--no-verify`` をつけてcommitを実行したときは呼び出されない。
  このスクリプトが終了コード0以外で終了するとコミットが中断される。
  サンプルでは行末に空白が残っているかどうかを検査して、残っていればコミットを中断する。
prepare-commit-msg
  commitを実行した時にデフォルトのコミットメッセージを用意したあとに呼び出される。
  引数として1〜3個受け取る。
  引数の一つ目はデフォルトのコミットログメッセージが書かれているファイルパス。
  引数の二つ目はコミットメッセージソースを表す文字列で、
  ``message`` (``-m`` か ``-F`` をつけて実行した)、
  ``template`` (``-t`` でコミットログのテンプレートが指定されて実行した、もしくはcommit.template設定がされている)、
  ``merge`` (マージコミットである、もしくは ``.git/MERGE_MSG`` が存在する)、
  ``squash`` (スカッシュコミットである)、
  終了コード0以外で終了するとコミットが中断される。
commit-msg
  commitを実行した時に呼び出される。
  ``--no-verify`` をつけてcommitを実行したときは呼び出されない。
  引数としてコミットメッセージの書かれたファイルパスを受け取る。
  終了コード0以外で終了するとコミットが中断される。
  このフックスクリプトによってコミットメッセージを書き換えることができるので、
  プロジェクト標準形式へフォーマットしたりするのに使用したり、
  不正な形式だったらコミット拒否するのに使用したりすればいいんじゃないかな。
  サンプルでは"Signed-off-by"で始まる行が複数現れていないかをgrepで検査して、
  もしあればコミットを中断する。
post-commit
  commitを実行したあとに呼び出される。引数はなし。
  このフックスクリプトはコミットに影響を与えないので、主に通知のために使用する。
pre-rebase
  rebaseを実行した時に実行される。
  よからぬ作業をやろうとしたときにリベースを中断させることができる。
post-checkout
  checkoutを実行してワークツリーが更新されたあとに呼び出される。
  引数として3個受け取る。
  引数の一つ目は前回のHEAD名、二つ目は新しいHEAD名、
  三つ目はブランチのチェックアウト(flag=1)なのか、
  ファイルのチェックアウトなのか(flag=0)のフラグを受け取る。
  checkoutを実行した後なのでこのスクリプトによってキャンセルすることはできない。
  ``--no-checkout`` なしでcloneしたときにも呼び出される。
  その場合は引数の一つ目はnullに、二つ目は新しいHEADに、三つ目は必ず1になる。
  使い方としてはリポジトリのバリデートチェックや前回のHEADとのdiffを表示したり、
  作業ディレクトリのメタパラメータの設定をしたりするのに使える。
post-merge
  mergeを実行したあとに実行される。
  引数としてスカッシュ(squash)マージされたかどうかが渡される。
  このフックスクリプトはpre-commitスクリプトとよく一緒に使われ、
  ワーキングツリーのメタデータの保存やリストアを行う例があげられる。

--------------------
サーバサイド用フック
--------------------
リモートリポジトリの.git/hooks以下に配置され、クライアントからのアクションによって
機能するスクリプト郡です。githubなど自分でリモートリポジトリを管理できない場合には
すべての機能が使えないことが多いです。
※githubだとpost-updateでユーザ指定のURLを叩くことが可能。

pre-receive
  リモートリポジトリでgit-receive-packが実行される時に呼び出される。
  これはローカルリポジトリでpushされたときに呼び出される。
  リモートリポジトリが更新される時に呼び出され、終了コードによって
  更新を失敗とすることが可能。
  このフックは引数を受け取らないが、標準入力から更新情報を取得できる。
  標準出力、標準エラー出力はgit send-packをたどって相手に送られる。
update
  pre-receiveと同様、リモートリポジトリでgit-receive-packが実行される時に呼び出される。
  リモートでの参照が変更される前に呼び出され、終了コードによって
  参照の更新を失敗にすることができる。
  このスクリプトによって、強制アップデート(例えば ``push -f`` )を禁止させる
  ことや、fast-forwardマージ以外を禁止するために利用できる。
  標準出力、標準エラー出力はgit send-packをたどって相手に送られる。
  サンプルでは注釈のないタグを禁止するかどうかをconfigで指定できるスクリプトになっている
  （他のものに比べて長い。128行あった）。
post-receive
  pre-receive, updateと同様、リモートリポジトリでgit-receive-packが実行された時に呼び出される。
  後で出てくるpost-updateの代わりとして出てきた。
  pushが完了した時に呼び出され、終了コードはpushの成否に影響しないので
  主に通知のために使用される。
  標準出力、標準エラー出力はgit send-packをたどって相手に送られる。
post-update
  pre-receive, update, post-receiveと同様、リモートリポジトリでgit-receive-packが実行された時に呼び出される。
  pushが完了した時に呼び出され、引数として更新された参照の名前をリストで受け取る。
  主に通知のために使用される。
  post-updateでは更新があった参照の元の値を知ることができないので、
  それを知りたい場合は先述の ``post-receive`` を使用すること。
  サンプルではupdate-server-infoを実行する。
pre-auto-gc
  ``gc --auto`` が実行される時に呼び出される。
  終了コードが0以外の時はgc --autoは実行されない。
post-rewrite
  ``commit --amend`` や ``rebase`` など、コミットを書き換えた時に呼び出される。
  ``filter-branch`` の実行時は *呼び出されない* 。
  標準入力から書き換えられたコミットのリビジョンを取得することができる。

========
終わりに
========
最近ハマっているJenkinsの話とそれに絡める形でgitのフックスクリプトの紹介を行いました。
仕事でも趣味でも「三回同じ事をやったら自動化する」をモットーに、執事に仕事を任せた堕落した生活を目指しましょう！
