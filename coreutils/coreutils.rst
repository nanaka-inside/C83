
Coreutils 大全
==============

どうも@tboffice [#twitter-tboffice]_ です。前回はasteriskでオレオレコールセンターの作り方を書いていました。今回は話題をガラッと変えてCoreutils大全と称してCoreutilsを一通り解説してみたいと思います。
たとえば、

* cdのオプションはいくつあるでしょう
* catを単独で打ったときの挙動は？
* factorコマンドは何をするでしょう

などなど。一部だけなら知っているけど全部知らない人のためにCoreutilsの中身を一通り説明します。
また、筆者が使っていて便利だなと思うTipsも載っけました。Coreutilsから往々に脱線していますが、そのあたりは目をつぶってやってください。それでは、深遠なるCoreutilsの世界へようこそ。


Coreutilsとは
-------------
lsやcatなど、linuxでは欠かせないコマンドをまとめたパッケージです。Fileutils, Shellutils, Textutilsを統合したものです。CoreutilsのChangeLogをみたところ、一番古い日付は2002-07-01でした。おそらくそのころに統合されたのでしょう。メジャーバージョンは2003年4月にバージョン5として登場しました。

ほかにUtils系ってないの？という話をすると、binutils(stringsコマンドとかが含まれている), findutils(findとかxargsとか), inetutils(pingとか)があります。 


本校の構成
----------
最初にcoreutilsパッケージのコマンドに共通のオプションを解説し、coreutilsのマニュアルの通りにコマンドを並べています。


共通のオプション
-----------------
coreutilsに含まれているコマンド共通のオプションです。


--help 
~~~~~~
たとえば ls のコマンドのオプションを調べたいとき


.. code-block:: sh

   $ ls --help


簡易ヘルプはこのオプションをつかえば問題☆解決。え？問題が解決しない？そんなときはこんな感じです。


.. code-block:: sh

   $ man ls
   $ info coreutils 目的のコマンド


infoコマンドを打った後はEmacsのキーバインドなのでそこさえ気をつければ良いコマンドだと思いますよ（白目

--version
~~~~~~~~~~
バージョンを表示します。

``--``
~~~~~~~

このオプションを打った後は、オプションが無効になります。
たとえば、こんなコマンドを打ったとき


.. code-block:: sh

   $ ls -l -- -l


-lというファイルあるいはディレクトリをls -lで表示します。


.. core-block:: sh

   $ mkdir -- -l


とやると、``-l``というディレクトリが出来ます。touchでも同様。

``-``
~~~~~~

オプションじゃないよ！ [#haifn]_ 。オプションに見えるだけだよ？ホントだよ？すたんだーどいんぷっとを待つ記号だよ！受け取った結果はコマンドがよろしく処理するよ！
たとえばこんな感じだよ！あとで出てくるから覚えておいてね！

.. [#haifn] と、マニュアルに書いてある

.. code-block:: sh

   $ sort - 
   b # 打つべし
   a # 打つべし
   c # 打つべし
   Ctrl-d # って打つと下記のように表示されるよ！
   a
   b
   c


ファイルまるまる出力系
----------------------
ファイルが高まる出力系のコマンドです。ファイルの意識を高めましょう [#file-takamaru]_ 。

.. [#file-takamaru] どうやるんだろう

cat
~~~

情報系の授業や講義があると、linuxの基礎としてほぼ間違いなく出てくるコマンドですね。
言わずとしれた、ファイルを引数にとると、そのファイルの中身を表示しれくれるコマンドです [#cata]_ 。
fileというファイルの中身を出力するときにはこうします。

.. [#cata] 説明が足りないと気づいた方は正しいです。coreutilsのマニュアルの通りの説明は後ほど

.. code-block:: sh

   $ cat file


次に、マニュアルにあるオプションの読み方を説明します。マニュアルには


:: 

   cat [option] [file]...


とあります [#catb]_ 。

.. [#catb] ほかのコマンドのマニュアルもほぼ同様に書かれています


``[]``
   この括弧で囲まれている部分は省略可能です。オプションはいくつ付けてもよいです。
``...``
  この記号は引数がいくつでもいいよって言ってます

つまりこんな感じでコマンドを作ることが出来ます。

.. code-block:: sh

   $ cat -A -n hogefile fugafile piyofile


主なオプションの説明をします。

-E
   主なオプションとして行末がどこまで入ってるか分からないから表示

-n 
   行数を付けて

-T
   タブ文字も表示して欲しいなぁ

-v 
   改行文字も表示して欲しいなー

-A
   -vETと同じ。改行文字、行末文字、タブも表示します

オプションのFILE部分に - を入れると標準入力になります。fとgというファイルがあって、

.. code-block:: sh

   cat f - g 

このようにコマンドが実行されたときは、fの内容を表示、標準入力の内容表示、ctrl-d(入力の終わり)を押したらgの内容が表示されます。
cat単独で打ったときは --- マニュアル通りの説明をすると、「ファイルまたは標準入力を標準出力にコピーする」 [#catm]_ です。
引数が指定されていないときは標準入力になります。標準入力と標準出力を体感してください。

.. [#catm] cat copies each file (‘-’ means standard input), or standard input if none are given, to standard output. 


tac
~~~
linuxの講義があっても出てくる頻度はかなり低いのではないでしょうか。
catのあとのtac。お察しの通りです。早速、実行してみましょう。ファイルを作るのが面倒なのでechoしてます。


.. code-block:: sh

   $ echo -e "a\nb\nc" | tac
   c
   b
   a


はい、ファイルの内容を上下逆に出します。1行分の文字の並びを逆にするには、 rev コマンドを使ってください。
誰得魔方陣の例。

.. code-block:: sh

   $ echo -e "2 9 4\n7 5 3\n6 1 8" | tac | rev 


単語単位で逆にするには、

.. code-block:: sh

   $ tac -r -s '[^a-zA-z0-9\-]' file


revと同じ効果をtacでやるには下記。ただし日本語の2バイト文字列も逆にするので化けます。おちゃめさんですね（何 [#taca]_ 


.. code-block:: sh

   $ tac -r -s '.\|' myfile

.. [#taca] 単語単位で逆にする例、とrevの効果の例は下記に載っていました。http://www.gnulinuxclub.org/index.php?option=com_content&task=view&id=189&Itemid=50



nl
~~~
行番号を振ってくれるコマンド。単に実行した場合はこんな感じです。

.. code-block:: sh

   $ nl /etc/issue                                                                
   1  CentOS release 5.7 (Final)
   2  Kernel \r on an \m
    

デフォルトだと、空行には番号がつかないです。なお、cat -b fileと同じです。
オプションに``-b a``を付けると空行でも行番号がつきます。いろいろオプションがあるので値を変更してみてください。

.. code-block:: sh

  $ echo -e "hoge\n\nfuga\npiyo" | nl -b a -n rz -s " hoge: " -v 3 -w 3
    003 hoge: hoge
    004 hoge: 
    005 hoge: fuga
    006 hoge: piyo


od
~~~
ファイルを8進数や16進数で表示するコマンド。デフォルトでは8進数で表示。
なんとなくxxdを使ってしまって、出番のないコマンドのような...


.. code-block:: sh

  $ od /etc/issue
  0000000 062503 072156 051517 071040 066145 060545 062563 032440
  0000020 033456 024040 064506 060556 024554 045412 071145 062556
  0000040 020154 071134 067440 020156 067141 056040 005155 000012
  0000057


base64
~~~~~~
データを印刷できる形式に変換するコマンド、とマニュアルには書いてあります。
RFC 4648に則ってデータを変換するコマンドで、133%データが大きくなります。デコードも出来ます。

.. code-block:: sh

   $ base64 /etc/issue | base64 --decode -i
   CentOS release 5.7 (Final)
   Kernel \r on an \m



体裁を整える系
--------------

fmt
~~~
テキストファイルの文字を適当に折り返してくれるコマンド。すでに改行されてしまっているテキストファイルでもなんとかしてくれます [#fmta]_ 。

.. [#fmta] wikipediaのサンプルが易しいです。http://en.wikipedia.org/wiki/Fmt


pr
~~~
印刷用にヘッダとフッタを自動的に追加してくれてくれるコマンド。RFCみたいな文章がすぐに出来るよ！プレーンテキストすばらしい！と筆者の脳内で大好評のコマンドです。お試しあれ。ただし使いどころは限定的です。

pr | pr してもヘッダとフッタが二重につくだけなのでやめてください。


fold
~~~~
テキストファイルをぴったりの文字数で改行するコマンド。fmtは空気を読んで、単語をぶったぎらないようにしていますが、このコマンドは空気を読まずにぶった切ります。fmtの様な挙動をさせるには、-sをつけるとある程度空気を読んでくれます。fmtは引用符の中は改行しませんが、foldは改行します。


ファイルの一部を出力
--------------------

head
~~~~~
ファイルの最初の10行を表示するコマンドです。
-n 5で先頭5行を表示。-c 10KB で先頭何キロバイトを表示するか指定します。headコマンドを宗教上の理由で打ちたくない人は、sed 10q と打ってください。
-n のあとにマイナス値を打つとどうなるでしょうか。環境にもよりますが...自分でやってみてください。


tail
~~~~~
ファイルの最後の10行を表示するコマンド。サーバ管理者は毎日打っていると言っても過言ではないコマンド。
-f オプションをつけることによって、ターゲットのファイルに対して追加された文字が出てきます。ちなみに複数のファイルを食わせることができるので、アクセスログファイルとアクセスエラーログファイルの両方をtail -f で表示することも可能。パイプでつないで特定の文字列だけ出力することも可能。

.. code-block:: sh
   
   tail -f apache-access.log apache-error.log | grep --color -E "(==|192.168.0.1)"


ログファイルから==または、192.168.0.1という文字列を抜き出しています。"=="というのは、やってみてのお楽しみ [#taila]_ 。

.. [#taila] ちなみにgrepの--colorオプションはこのURLで知りました。http://aerith.mydns.jp/regrets/2008/12/tail-color.html


tailコマンドといえば、tailfコマンドに触れないわけにはいかないでしょう。tail -f コマンドと同じような働きをする tailf コマンドがあります。
結論から言うと、最新のcoreutilsを使っているならどっちも変わりありません [#tailaa]_ 。どちらも inotify イベントを受け取って処理するようになっています。

.. [#tailaa] coreutils version 7.5でinotifyに対応した模様です。ここを参照しました。http://dev.ariel-networks.com/Members/inoue/tailf/

もしも、対象のファイルが消えてしまうときは、ファイルを読み直す下記のオプションを使いましょう。


.. code-block:: sh

   tail -F filename


余談。-r  オプションがあったのですが、coreutilsには実装されていません。tacコマンドを使ってください。

split
~~~~~~
ファイルを分割するコマンドです。
書式は下記です。

.. code-block:: console

   split [option] [input [prefix]]

デフォルトで実行するとこんな感じになります。

.. code-block:: sh

   $ split hogefile
   $ ls 
   hogefile xaa  xab  xac  xad  xae  xaf  xag  xah  xai 

1000行ごとに1ファイルを、カレントディレクトリに生成します [#splita]_ 。xaa xab ... となっているのは、あとでcatすると元に戻る [#splitb]_ からです。100行ごとに分割してほしいとか、こんなファイル名いやだというときはこんな感じです。

.. [#splita] でかいサイズのファイルのときには注意。たくさんファイルができるよ！！
.. [#splitb] cat x* する。xの次はy,zと使っていく。最後どうなるのか実験だ！


.. code-block:: sh
   
   $ split -l 100 hogefile AA
   $ ls 
   hogefile AAaa  AAab  AAac  AAad  AAae  AAaf

-bオプションで任意のバイト数でsplitすることができます。分割しながら圧縮できる(filterに通す)というオプションもあります [#splitc]_ [#splitd]_ [#splite]_ [#splitf]_ [#splitg]_ 。

.. [#splitc] xz -dc BIG.xz | split -b200G --filter='xz > $FILE.xz' - big- (マニュアルより。big-aa.xz, big-ab.xzといったようにファイルが出来上がります)
.. [#splitd] ディスクの単価が安い現代に需要があるかどうか... 
.. [#splite] あるって!開発環境とかいつもディスク枯渇してるじゃん!!
.. [#splitf] 開発環境でsplitする用途があるか疑問だにゃあ
.. [#splitg] 脚注で会話するなよ

非常に使いどころが謎ですが、-nオプションの例を示します。

.. code-block:: sh
   $ seq 100 > k; split -nl/7/33 k
   20
   21
   22


csplit
~~~~~~~
「ファイルを文脈ベースで分割する」コマンドです。端的には、特定の文字が出てきたらsplitするコマンドです。使いどころによっては非常に強力なコマンドです。
書式は下記。

.. code-block:: sh

   csplit [option]... input pattern...


下記のようにすると、最初にendという文字と遭遇したら、別のファイルをつくって、そこに出力します。もとのファイルはそのまま残っています。そして2ファイル出来上がり、2つめの1行目に ``end`` という文字が含まれています。

.. code-block:: sh 

   $ csplit hogedfile /end/

さてマニュアルを追ってみましょう。ファイルがたくさんできるから、最初にディレクトリを作り、その中にcdしましょうと書いてあります。

.. code-block:: sh 
   $ mkdir d && cd d

次に0または5で終わる文字にマッチしたら、そこでまた別のファイルを作ってそこに出力します。 ``{*}`` があるので、マッチしたぶんだけファイルが生成されます。出力されている数字は、それぞれのファイルのバイト数です。

.. code-block:: sh 

   $ seq 14 | csplit - '/[05]$/' '{*}'
   8
   10
   15
   $ ls
   xx00  xx01  xx02

ファイルの中身が、なんとなくどうなっているか分かったところでおわりです。


ファイルの要約系
----------------

wc
~~~
ファイルの行数を知るときによく出るコマンドです。wc -l が有名すぎて、wc単体の結果についてはmanを引かないと忘れてることが多いです。筆者も忘れています [#wca]_ 。

.. [#wca] デフォルトでは、行数、単語数、バイト数を出力しますか？\\つまんねーこと聞くなよ／

-L オプションで、ファイルの中で一番長い行の長さが出ます。また、下記の例では、\*.c または \*.hファイルのリストから、1行の行数が一番長い行の文字列を表示します。

.. code-block:: sh
   find . -name '\*.[ch]' -print0 | wc -L --files0-from=- | tail -n1


sum
~~~
BSDのアルゴリズムで16bitのファイルのチェックサムと1024バイト単位のブロック数を表示するコマンド。
-sオプションでSyatem Vのアルゴリズムを使ってのチェックサムと、512バイト単位のブロック数を表示 [#suma]_ 。

.. [#suma] と、とくに引っ掛かりもなく書いてますが、筆者はBSDやらSystem Vは名前を聞いたことある程度の知識だったりします。BSDに関していえば、学生の頃netBSDで自宅サーバたててたくらいしか接点がないです


cksum
~~~~~
ファイル名を引数に取ると、CRC [#cksum]_ のチェックサムを表示します。

.. [#chksum]_ 巡回冗長検査。Cyclic Redundancy Check のこと。詳しくはwikipdiaへ


md5sum
~~~~~~
128bitのチェックサム(またはフィンガープリントまたはメッセージダイジェスト [#md5sumbb]_ )を計算します。リリースするバイナリと、本番でデプロイされているバイナリが一致しているかどうか確かめる時にたまに使います [#md5sum]_ 。

.. [#md5sumbb] この本を読んでいるのにフィンガープリントとメッセージダイジェストを知らないだと!?出直してこい!!と言われないように、知らない人は調べましょう
.. [#md5sum] 突然真面目にTipsだしてきたよこの筆者

md5dumが一致するかどうか確かめましょう [#md5sumb]_ 。

.. code-block:: sh

   $ touch a && md5sum a > a.sum
   $ md5sum -c a.sum
   a: OK

.. [#md5sumb] d41d8cd98f00b204e9800998ecf8427e という謎の文字列をググると191万件ヒットしました



sha系
~~~~~~~

sha系と、sha2で始まるコマンドをまとめました。

sha1sum 
  SHA-1のダイジェストを計算します。md5sumより安全なダイジェストです。SHA-2にとってかわられて徐々に廃止すべき、とマニュアルに書かれています。

sha2系コマンド
  sha224sum, sha256sum, sha384sum, sha512sumというコマンドがあります。それぞれのビット長のSHAダイジェストを計算します。オプションは、md5sumと同じです。


ソート・アート・オンライン系
----------------------------
ファイルの中身をソートするコマンド群です [#sao]_ 。

.. [#sao] 某SAOとは関係ないです


sort
~~~~~
ファイルをソートするコマンド...と書き始めたかったのですが、それ以外にも機能があります。
ファイルを、ソート、マージ、または比較し、表示します。実は3つのモードを持っていて、ソートするモード、マージするモード、ファイルがソートされているかチェックするモードがあります [#sort1]_ 。

.. [#sort1] マニュアルをちょっと意訳してます

チェックオプションのサンプルは下記のようになります。

.. code-block:: sh

   $ seq 12 > k; sort -c k
   sort: k:10: disorder: 10


マージのオプションはこんな感じです。あらかじめソート済みのファイルを流し込んでやるとソートしてくれます。そのため、seqコマンドであらかじめ連続したデータを作っておきます。せっかくなのでheadコマンドで表示してみました。

.. code-block:: sh

   $ seq 0 2 10 > a
   $ seq 1 2 10 > b
   $ head a b 
   ==> a <==
   0
   2
   4
   6
   8
   10

   ==> b <==
   1
   3
   5
   7
   9

次に、こんなソートを試します。

.. code-block:: sh

   $ sort a b
   0
   1
   10
   2
   3
   4
   5
   6
   7
   8
   9

10は後ろに持ってきたいですよね。そんなときには、-n [#sort-n]_ または-g [#sort-g]_ または-h [#sort-h]_ を付けて下さい。

.. [#sort-n] マイナスがついている数値でもソートしてくれます
.. [#sort-g] マイナスやプラスの記号がついていてもソートしてくれます
.. [#sort-h] echo -e "+4\n1G\n30K\n-1" | sort -h などと打ってもK,Gを認識してソートしてくれます。誰得

-uで重複をはじいてくれたり、-rで逆順にしたり、csvデータの特定の数値だけを基準にして並べてくれたり、IPアドレスを小さい順に並べるといったことも可能です。あとはマニュアルとにらめっこして下さい [#sort-tr]_ 。

.. [#sort-tr] coreutilsのソースを眺めると分かるんですが、lsに次いでソースのサイズが大きいです

shuf
~~~~~
ファイルをshuffleしてくれます [#shuf-1]_ 。
もしseqをつかって数字をランダムに出したいときはいったん思いとどまって、下記のようにして下さい [#shuf-2]_ 。

.. code-block:: sh

   $ shuf -i 1-4                                                                      
   3
   1
   2
   4

.. [#shuf-1] CentOS5.7な環境でコマンドうったら出てこない!それもそのはず、CentOSのcoreutilsのバージョンが古いのでした(5.97)。バージョン6.4から新しく加入したコマンドです。amazon ec2には 8.4 が入ってました
.. [#shuf-2] 当然、この通りに出てくるわけではありません。--random-source=FILE というオプションもあるのでこだわりたい方はこだわれます

uniq
~~~~
ソート済みのファイルを引数に取ると、重複行を取り除いたデータを書き出してくれます [#uniq-1]_ 。
sortにも-uオプションがあり、uniqコマンドを単体で打ったときと同じようなことをやってくれます。
よく使うパターン [#uniq-2]_ 


.. code-block:: sh

   cat file | sort | uniq -c | sort -nr | head

.. [#uniq-1] テストに出るぞー
.. [#uniq-2] fileに出現した同じ文字列を出現順にランキング表示です。サーバ管理者でこれが出来なかったら落第だ！

comm
~~~~
2つのファイルを比較して、片方にしかないデータ、両方にしかないデータなどを出力してくれます [#comm-1]_ 。
ベン図をもってきてきちんと整理してデータの集計に当たりましょう。実行結果が独特なのでサンプルを載せます。

.. code-block:: sh

   $ seq 1 3 9 > q
   $ seq 1 2 9 > w
   $ head q w                                                                         
   ==> q <==
   1
   4
   7

   ==> w <==
   1
   3
   5
   7
   9
   $ comm q w
                  1
           3
     4
           5
                  7
           9

.. [#comm-1] 通話のアプリじゃないですよ。念のため

ptx
~~~~
tsort
~~~~~

テーブルの欄操作
----------------
cut
~~~
paste
~~~~~
join
~~~~

キャラクタ操作
----------------

tr
~~~

expand
~~~~~~~
unexpand
~~~~~~~~

ファイルリスト表示
------------------
ls
~~~
あああああ。


dir
~~~
あれ？windowsのコマンドじゃないの？

vdir
~~~~
dircolors
~~~~~~~~~

基本的操作
----------
cp
~~~
ln
~~~
ln -sしか使わなくね？

mkdir
~~~~~
mkfifo
~~~~~~
mknod
~~~~~~
readlink
~~~~~~~~~
rmdir
~~~~~
unlink
~~~~~~

ファイルの属性を変更
--------------------
chown
~~~~~
chgrp
~~~~~
chmod
~~~~~
touch
~~~~~

ディスク容量
------------
df
~~
du
~~
デュフフのduと覚えている

stat
~~~~~
自分自身で触ってatime変えたりするので注意

sync
~~~~~
3 syncなんて古い人間はいねがー

truncate
~~~~~~~~

文字を表示
-----------

echo
~~~~

printf
~~~~~~
yes
~~~
yes!アスミス

条件
----
false
~~~~~
true
~~~~
test
~~~~
expr
~~~~

リダイレクション
----------------
tee
~~~~

ファイル名操作
--------------
basename
~~~~~~~~
dirname
~~~~~~~
pathchk
~~~~~~~~
mktemp
~~~~~~
realpath
~~~~~~~~

作業の状況
----------
訳が難しい。http://www.geocities.jp/fut_nis/html/coreutils-ja/Working-context.html
から借りた。

pwd
~~~~
stty
~~~~
printenv
~~~~~~~~
tty
~~~

ユーザの情報
-------------
id
~~~
logname
~~~~~~~
whoami
~~~~~~
わたしはだあれ？コマンド

groups
~~~~~~
users
~~~~~
who
~~~
誰？

システム情報
------------

date
~~~~~
arch
~~~~
nproc
~~~~~
あれ、新しめのコマンドぽい

uname
~~~~~~
hostname
~~~~~~~~
打ってみれば分かる

hostid
~~~~~~
uptime
~~~~~~

SELinux関連
-----------
chcon
~~~~~
runcon
~~~~~~
らんこん

コマンド生成を制御する
----------------------
chroot
~~~~~~
env
~~~
nice
~~~~
nohup
~~~~~
stdbuf
~~~~~~
timeout
~~~~~~~~
小数入れられたっけ？

プロセス操作
-------------
kill
~~~~
ネットワーク系のプロセスに -9 すんなよ！ってばっちゃがいってた
たしかmysql

遅刻
----
sleep
~~~~~

数値関連
--------
factor
~~~~~~
素因数分解をがんばってやってくれる。おわり

seq
~~~~
よく使う


共通のオプション(その2)
------------------------

.. note::
   注釈ですnote

.. warning::
   警告です。warning

.. rubric:: 脚注
.. [#twitter-tboffice] http://twitter.com/tboffice
.. [#core-nage1] 筆者が調べるのがおっくうなだけともいう
.. [#core-utils] ちなみにこの原稿はreStructureTextで書かれていますが、これを処理するのはDocutilsだったり。gnuじゃないけどね
.. [#utils-combine] "The last separate versions were fileutils-4.1.11, textutils-2.1, and sh-utils-2.0.15. The first major release of coreutils-5.0 was announced on Fri, 4 April 2003." (http://www.gnu.org/software/fileutils/fileutils.html)
